# Порівняння сортувань: Insertion vs Merge vs Timsort (Python)

**Методика.** Заміряли час (медіана з repeat) через `timeit` на наборах:
Random, Sorted, Reversed, Nearly-sorted (1% swaps); розміри: {SIZES}.
Порівнювали власні реалізації **Insertion** і **Merge** з вбудованим **Timsort** (`sorted`).

**Теорія.**
- Insertion: O(n²) у середньому/гіршому; O(n) на майже відсортованих.
- Merge: стабільні O(n log n).
- Timsort: гібрид вставок і злиття + детекція відсортованих «ранів» — близький до O(n) на добрих випадках; O(n log n) у гіршому.

**Практика (за замірами):**
- **Timsort** найшвидший або близький до найшвидшого на всіх наборах.
- **Insertion** дуже швидкий на відсортованих/майже відсортованих і малих n, але різко програє на випадкових/реверсних (O(n²)).
- **Merge** стабільний, але повільніший за Timsort у Python через накладні витрати рекурсії/копій.

**Висновок.** Поєднання **вставок** (на малих підпослідовностях) і **злиття** (на великих) робить **Timsort** значно ефективнішим. 
Тому в реальних задачах доцільно використовувати вбудовані сортери Python (`sorted`, `.sort()`), а власні реалізації — для навчання або спецвипадків.